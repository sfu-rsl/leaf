//pub enum Rvalue {
//    /// Yields the operand unchanged
//    Use(Operand),
//
//    /// Creates an array where each element is the value of the operand.
//    ///
//    /// This is the cause of a bug in the case where the repetition count is zero because the value
//    /// is not dropped, see [#74836].
//    ///
//    /// Corresponds to source code like `[x; 32]`.
//    ///
//    /// [#74836]: https://github.com/rust-lang/rust/issues/74836
//    Repeat(Operand, ty::Const),
//
//    /// Creates a reference of the indicated kind to the place.
//    ///
//    /// There is not much to document here, because besides the obvious parts the semantics of this
//    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing
//    /// exactly what the behavior of this operation should be.
//    ///
//    /// `Shallow` borrows are disallowed after drop lowering.
//    Ref(Region, BorrowKind, Place),
//
//    /// Creates a pointer/reference to the given thread local.
//    ///
//    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a
//    /// `*const T`, and if neither of those apply a `&T`.
//    ///
//    /// **Note:** This is a runtime operation that actually executes code and is in this sense more
//    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to
//    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.
//    ///
//    /// **Needs clarification**: Are there weird additional semantics here related to the runtime
//    /// nature of this operation?
//    ThreadLocalRef(DefId),
//
//    /// Creates a pointer with the indicated mutability to the place.
//    ///
//    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like
//    /// `&raw v` or `addr_of!(v)`.
//    ///
//    /// Like with references, the semantics of this operation are heavily dependent on the aliasing
//    /// model.
//    AddressOf(Mutability, Place),
//
//    /// Yields the length of the place, as a `usize`.
//    ///
//    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not
//    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is
//    /// ill-formed for places of other types.
//    Len(Place),
//
//    /// Performs essentially all of the casts that can be performed via `as`.
//    ///
//    /// This allows for casts from/to a variety of types.
//    ///
//    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why
//    /// `ArrayToPointer` and `MutToConstPointer` are special.
//    Cast(CastKind, Operand, Ty),
//
//    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second
//    ///   parameter may be a `usize` as well.
//    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,
//    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be
//    ///   matching, up to the usual caveat of the lifetimes in function pointers.
//    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the
//    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is
//    ///   truncated as needed.
//    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching
//    ///   types and return a value of that type.
//    /// * The remaining operations accept signed integers, unsigned integers, or floats with
//    ///   matching types and return a value of that type.
//    BinaryOp(BinOp, Box<(Operand, Operand)>),
//
//    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the
//    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be
//    /// unequal to the actual result and sets the `bool` if this is the case.
//    ///
//    /// This only supports addition, subtraction, multiplication, and shift operations on integers.
//    CheckedBinaryOp(BinOp, Box<(Operand, Operand)>),
//
//    /// Computes a value as described by the operation.
//    NullaryOp(NullOp, Ty),
//
//    /// Exactly like `BinaryOp`, but less operands.
//    ///
//    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;
//    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds
//    /// return a value with the same type as their operand.
//    UnaryOp(UnOp, Operand),
//
//    /// Computes the discriminant of the place, returning it as an integer of type
//    /// [`discriminant_ty`].
//    ///
//    /// The validity requirements for the underlying value are undecided for this rvalue, see
//    /// [#91095]. Note too that the value of the discriminant is not the same thing as the
//    /// variant index; use [`discriminant_for_variant`] to convert.
//    ///
//    /// For types defined in the source code as enums, this is well behaved. This is also well
//    /// formed for other types, but yields no particular value - there is no reason it couldn't be
//    /// defined to yield eg zero though.
//    ///
//    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty
//    /// [#91095]: https://github.com/rust-lang/rust/issues/91095
//    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant
//    Discriminant(Place),
//
//    /// Creates an aggregate value, like a tuple or struct.
//    ///
//    /// This is needed because dataflow analysis needs to distinguish
//    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`
//    /// has a destructor.
//    ///
//    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After
//    /// generator lowering, `Generator` aggregate kinds are disallowed too.
//    Aggregate(Box<AggregateKind>, Vec<Operand>),
//
//    /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.
//    ///
//    /// This is different from a normal transmute because dataflow analysis will treat the box as
//    /// initialized but its content as uninitialized. Like other pointer casts, this in general
//    /// affects alias analysis.
//    ShallowInitBox(Operand, Ty),
//}
