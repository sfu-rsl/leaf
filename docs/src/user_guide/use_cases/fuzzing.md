# Fuzzing

One of the effective use cases of concolic execution is demonstrated to be
hybrid fuzzing, where fuzzing is aided with solver-found inputs generated by symbolic
execution to take certain paths inside the program that other techniques are inefficient
to find.

Leaf is designed to be easy to integrate within existing stacks and
comes with a built-in support for [LibAFL][1],
a customizable fuzzing framework with modern architecture written in Rust.

Crate `libafl_leaf` contains facilities for using Leaf-instrumented
programs with the fuzzers written using this library.

## Hybrid Fuzzing for libFuzzer

In an abstract manner, hybrid fuzzing for LibAFL-based fuzzers is achievable using
a stage that generates diverging inputs from the current test case.
This stage should perform the concolic execution using the current test case to derive the diverging inputs
and offer them to the fuzzer for evaluation.
Thus, the following steps are presumable for an execution-based concolic executor like Leaf.
1. Build an executable equivalent to the fuzz target, which is suitable for concolic execution.
1. Define a mutator stage that runs the built executable and obtains new inputs.
1. Add the stage to the fuzzer.

The mentioned ingredients are provided by Leaf.
`leafc` instruments your target program,
`leafo_onetime` helps with collecting the diverging inputs,
and `libafl_leaf` provides the stage.
As `libFuzzer` (through `cargo-fuzz`) is one the most-used to perform fuzzing
for Rust projects, a rudimentary built-in support is also provided for harnesses
written based on [libfuzzer-sys](https://github.com/rust-fuzz/libfuzzer)
to upgrade them to a hybrid fuzzer.
It is developed as extension of [LibAFL][1]'s implementation of `libFuzzer`, so
the [same instructions](https://github.com/AFLplusplus/LibAFL/tree/main/libafl_libfuzzer) applies
for the integration.

### Recipe

With an understanding of the general procedure above, you can follow the instruction
below to upgrade your existing fuzzer to a hybrid one.

* Prerequisites
    1. The one-time orchestrator is installed in your environment.
        If not, install it similarly to `leafc` using the following command in Leaf's root folder.
        ```console
        leaf$ cargo install --path ./orchestrator
        ```

    1. You already have a fuzzer written using `libfuzzer-sys` like below.
    We assume it is named as `fuzz_target_1` in the instructions.
        ```rust
        #![no_main]

        use libfuzzer_sys::fuzz_target;

        fuzz_target!(|data: &[u8]| {
            // fuzzed code goes here
        });
        ```

1. Replace `libfuzzer-sys` source to Leaf's implementation in `Cargo.toml` of your fuzz project.
    ```toml
    # From
    libfuzzer-sys = { version = "...", features = ["your", "features", "here"] }

    # To
    libfuzzer-sys = { git = "https://github.com/sfu-rsl/leaf.git", package = "libafl_libfuzzer", features = ["your", "features", "here"]}
    ```

1. Change `fuzz_target` macro invocation to `hybrid_fuzz_target` and make
    `no_main` attribute conditional based on compilation with `leafc`.
    ```rust
    #![cfg_attr(not(leafc), no_main)]

    use libfuzzer_sys::hybrid_fuzz_target;

    hybrid_fuzz_target!(|data: &[u8]| {
        // fuzzed code goes here
    });
    ```
    (`hybrid_fuzz_target` generates a program with a `main` function that reads
    the whole standard input, marks it as symbolic, and passes to the closure.)

1. Build your fuzz target with `leafc` in a *separate* cargo target directory like below.
    ```console
    fuzz$ RUSTC=leafc cargo build --bin fuzz_target_1 --target-dir ./target/leaf
    ```

1. Build your fuzzer normally, e.g.,
    ```console
    fuzz$ cargo fuzz build fuzz_target_1
    ```

1. Run your fuzzer with the additional argument `conc_program` which points to the
    instrumented executable built using `leafc`.
    ```console
    fuzz$ cargo fuzz run fuzz_target_1 -- -conc_program=./target/leaf/debug/fuzz_target_1
    ```

-----------------

Please refer to the technical documentation for further details about the components and steps mentioned above.


[1]: https://github.com/AFLplusplus/LibAFL