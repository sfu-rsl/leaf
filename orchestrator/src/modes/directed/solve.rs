use core::iter;
use std::{
    borrow::Borrow,
    cell::RefCell,
    collections::{HashMap, HashSet},
    rc::Rc,
};

use disjoint::DisjointSet;
use tracing::Span;

use common::{
    directed::{CfgConstraint, CfgEdgeDestination, ProgramMap, RawCaseValue},
    log_debug, log_warn,
    pri::{BasicBlockIndex, BasicBlockLocation},
    types::trace::ConstraintKind,
    utils::comma_separated,
    z3::{AstAndVars, AstNode, AstNodeSort, BVNode, BVSort, WrappedSolver as Z3Solver},
};

use crate::{
    AntecedentSolvingStrategy, ProgramReachability, QSet, ReachabilityBiMap, SwitchStep,
    two_level::DirectedEdge, utils::tracing::IteratorInstrumentExt,
};

type ParsedDiscrValue<'ctx> = AstAndVars<'ctx, u32>;
type Constraint<'ctx> = common::types::trace::Constraint<ParsedDiscrValue<'ctx>, AstNode<'ctx>>;
type ParsedSwitchStep<'ctx> = SwitchStep<ParsedDiscrValue<'ctx>>;
type VariablesForest = Rc<DisjointSet>;

type SolverCache = HashSet<(usize, ConstraintKind<RawCaseValue>)>;

pub(crate) struct Solver<'ctx, 'a> {
    solver: Z3Solver<'ctx, u32>,
    trace: &'a [SwitchStep],
    parsed_trace: Vec<ParsedSwitchStep<'ctx>>,
    weakened_trace: Vec<ParsedSwitchStep<'ctx>>,
    vars_forests: Vec<Option<VariablesForest>>,
    antecedent_strategy: AntecedentSolvingStrategy,
    tried_decisions: RefCell<SolverCache>,
}

pub(crate) struct SolveResult<'ctx> {
    pub solver_result: z3::SatResult,
    pub answers: HashMap<u32, AstNode<'ctx>>,
    pub step_index: usize,
}

impl<'ctx, 'a> Solver<'ctx, 'a> {
    pub(crate) fn new(
        trace: &'a [SwitchStep],
        current_input: &[u8],
        p_map: &ProgramMap,
        reachability: &impl ProgramReachability,
        antecedent_strategy: AntecedentSolvingStrategy,
    ) -> Self {
        let mut solver: Z3Solver<_> = Default::default();
        let (vars, parsed_trace) = parse_trace(trace, solver.context());
        suggest_current_input_as_answer(&vars, current_input, &mut solver);

        let mut weakened_trace = parsed_trace.clone();
        weaken_steps(trace, p_map, reachability, weakened_trace.as_mut_slice());

        let vars_forests = make_vars_forests(&parsed_trace);

        Self {
            solver,
            trace,
            parsed_trace,
            weakened_trace,
            vars_forests,
            antecedent_strategy,
            tried_decisions: Default::default(),
        }
    }

    /// Tries to solve the path constraints to find answers that may take the edge requested.
    /// # Returns
    /// If the edge is not controllable by symbolic values, [None] is returned.
    /// Otherwise, the result for all ways to possibly take the edge is returned.
    /// Each result has the underlying SMT solver's result as well as the model generated by it.
    /// # Remarks
    /// - The metadata of the edge is the list of outgoing edges from the source switch node.
    /// - The answers generated, *may* take the requested edge. Answers that are known to
    ///   not take the edge are guaranteed to be generated.
    ///   In other words, it may return false positives but not true negatives.
    #[tracing::instrument(level = "debug", skip_all)]
    pub(crate) fn try_satisfy_edge(
        &mut self,
        edge: &DirectedEdge<'_, &[CfgEdgeDestination]>,
    ) -> Option<impl Iterator<Item = SolveResult>> {
        log_debug!(
            index = edge.src.trace_index,
            discr = edge.src.discr.as_ref().map(|d| d.to_string()),
            antecedents = comma_separated(edge.src.implied_by_offset.iter()),
            "Edge to satisfy: {} toward {}",
            &edge.src.location,
            edge.dst,
        );

        let index = self.trace.element_offset(edge.src);
        let constraints = &self.parsed_trace[..=index.expect("Inconsistent referencing")];
        let (last, prefix) = constraints.split_last().unwrap();

        // If (symbolic) constraint is available or some other have implied it.
        if last.discr.is_none() && last.implied_by_offset.is_empty() {
            return None;
        }

        let from_discr = last
            .discr
            .is_some()
            .then(|| self.satisfy_decision_toward(prefix, &last, edge.dst, edge.metadata))
            .into_iter()
            .flatten();

        let from_antecedents = self
            .change_antecedents_toward(prefix, &last, edge.dst, edge.metadata)
            .into_iter()
            .flatten();

        Some(
            from_discr
                .chain(from_antecedents)
                .instrumented(Span::current()),
        )
    }

    #[tracing::instrument(level = "debug", skip_all)]
    fn satisfy_decision_toward<'b, 'c>(
        &'b self,
        prefix: &'b [ParsedSwitchStep<'ctx>],
        step: &'b ParsedSwitchStep<'ctx>,
        dst: BasicBlockIndex,
        outgoing_edges: &'c [CfgEdgeDestination],
    ) -> impl Iterator<Item = SolveResult<'ctx>> {
        let kinds_to_satisfy =
            construct_constraint_kinds_to_satisfy(&step.decision, outgoing_edges, dst)
                .instrumented(Span::current());
        self.satisfy_decision_for_kinds(
            prefix,
            step,
            step.discr.as_ref().unwrap(),
            kinds_to_satisfy,
        )
        .instrumented(Span::current())
    }

    #[tracing::instrument(level = "debug", skip_all)]
    fn change_antecedents_toward<'b, 'c>(
        &'b self,
        prefix: &'b [ParsedSwitchStep<'ctx>],
        step: &'b ParsedSwitchStep<'ctx>,
        dst: BasicBlockIndex,
        outgoing_edges: &'c [CfgEdgeDestination],
    ) -> Option<impl Iterator<Item = SolveResult<'ctx>>> {
        if let AntecedentSolvingStrategy::None = self.antecedent_strategy {
            return None;
        }

        let not_taken = step.decision.clone().not();

        let can_take_another = cfg_constraints_to_kind(
            cfg_constraints_to(outgoing_edges, dst),
            outgoing_edges,
            step.decision.is_boolean(),
        )
        .any(|k| k.and(&not_taken, || case_count(outgoing_edges)).is_some());
        if !can_take_another {
            log_debug!("Already taken the desired edge, nothing to change");
        }

        Some(
            can_take_another
                .then(|| self.change_antecedents(prefix, step).unwrap())
                .into_iter()
                .flatten()
                .instrumented(Span::current()),
        )
    }

    fn satisfy_decision_for_kinds<'b, I: IntoIterator<Item = ConstraintKind<RawCaseValue>>>(
        &'b self,
        prefix: &'b [ParsedSwitchStep<'ctx>],
        step: &'b ParsedSwitchStep<'ctx>,
        discr: &'b ParsedDiscrValue<'ctx>,
        kinds: I,
    ) -> impl Iterator<Item = SolveResult<'ctx>> {
        log_debug!(
            "Changing decision: ({} @ {})",
            step.trace_index,
            step.location,
        );
        // Only send constraints for the participating variables.
        let vars_forest = self.vars_forests[prefix.len()].as_ref().unwrap();
        let vars_set_root = vars_forest.root_of(
            discr
                .variables
                .iter()
                .map(|(id, _)| *id as usize)
                .next()
                .unwrap(),
        );

        const USE_WEAKENED_TRACE: bool = true;
        let prefix = if USE_WEAKENED_TRACE {
            &self.weakened_trace[..prefix.len()]
        } else {
            prefix
        };
        let prefix = prefix
            .iter()
            .filter(|s| {
                s.discr.as_ref().is_some_and(|d| {
                    d.variables
                        .iter()
                        .any(|(id, _)| vars_forest.is_joined(vars_set_root, *id as usize))
                })
            })
            .map(|s| {
                let discr = s.discr.as_ref().unwrap();
                Constraint {
                    discr: discr.clone(),
                    kind: s.decision.as_ref().map(ast_mapper(&discr)),
                }
            })
            .collect::<Vec<_>>();

        let prefix_len = prefix.len();
        log_debug!("Found {} relevant constraints in the prefix", prefix_len);

        let to_satisfy = kinds
            .into_iter()
            .filter(move |k| {
                self.tried_decisions
                    .borrow_mut()
                    .insert((prefix_len, k.clone()))
            })
            .map(|k| k.map(ast_mapper(discr)))
            .map(|kind| Constraint {
                discr: discr.clone(),
                kind,
            })
            .inspect(|c| log_debug!("Constraint to satisfy: {c}"));

        to_satisfy
            .map(move |to_satisfy| {
                self.solver
                    .check(prefix.iter().cloned().chain(iter::once(to_satisfy)))
            })
            .map(|(smt_res, answers)| SolveResult {
                solver_result: smt_res,
                answers,
                step_index: step.trace_index,
            })
            .instrumented(Span::current())
    }

    fn change_antecedents<'b>(
        &'b self,
        prefix: &'b [ParsedSwitchStep<'ctx>],
        step: &'b ParsedSwitchStep<'ctx>,
    ) -> Option<impl Iterator<Item = SolveResult<'ctx>>> {
        if let AntecedentSolvingStrategy::None = self.antecedent_strategy {
            return None;
        }

        let result = match self.antecedent_strategy {
            AntecedentSolvingStrategy::ConjunctionNegation => todo!(),
            AntecedentSolvingStrategy::MultiAnswerNegation => antecedents(prefix, step)
                .rev()
                .map(move |(prefix, a_step)| {
                    log_debug!(
                        "Changing antecedent: ({} @ {}) => ({} @ {})",
                        a_step.trace_index,
                        a_step.location,
                        step.trace_index,
                        step.location,
                    );
                    Box::new(self.take_another_decision(prefix, a_step))
                        as Box<dyn Iterator<Item = SolveResult<'ctx>>>
                })
                .flatten(),
            AntecedentSolvingStrategy::None => unreachable!(),
        };
        Some(result)
    }

    fn take_another_decision<'b>(
        &'b self,
        prefix: &'b [ParsedSwitchStep<'ctx>],
        step: &'b ParsedSwitchStep<'ctx>,
    ) -> impl Iterator<Item = SolveResult<'ctx>> {
        let from_discr = step
            .discr
            .as_ref()
            .map(|discr| {
                self.satisfy_decision_for_kinds(
                    prefix,
                    step,
                    discr,
                    iter::once(step.decision.clone().not()),
                )
            })
            .into_iter()
            .flatten();

        let from_antecedents = self.change_antecedents(prefix, step).into_iter().flatten();

        from_discr.chain(from_antecedents)
    }
}

fn antecedents<'b, 'ctx>(
    prefix: &'b [ParsedSwitchStep<'ctx>],
    step: &'b ParsedSwitchStep<'ctx>,
) -> impl DoubleEndedIterator<Item = (&'b [ParsedSwitchStep<'ctx>], &'b ParsedSwitchStep<'ctx>)> {
    step.implied_by_offset
        .iter()
        .map(|offset| prefix[..=(prefix.len() - offset)].split_last().unwrap())
        .map(|(a, b)| (b, a))
}

fn suggest_current_input_as_answer<'ctx>(
    vars: &HashMap<u32, AstNode<'ctx>>,
    current_input: &[u8],
    solver: &mut Z3Solver<'ctx, u32>,
) {
    if vars.len() != current_input.len() {
        log_warn!("Current input does not align with the found symbolic variables");
        return;
    }

    for (id, var) in vars.iter() {
        solver.consider_possible_answer(
            var.clone(),
            AstNode::BitVector(BVNode(
                z3::ast::BV::from_u64(
                    solver.context(),
                    current_input[*id as usize - 1] as u64,
                    u8::BITS,
                ),
                BVSort { is_signed: false },
            )),
        );
    }
}

fn parse_trace<'ctx>(
    trace: &[SwitchStep],
    context: &'ctx z3::Context,
) -> (HashMap<u32, AstNode<'ctx>>, Vec<ParsedSwitchStep<'ctx>>) {
    let mut vars = HashMap::new();
    let parsed_trace = trace
        .iter()
        .map(|t| SwitchStep {
            discr: t.discr.as_ref().map(|d| d.parse(context, &mut vars)),
            trace_index: t.trace_index,
            location: t.location,
            decision: t.decision.clone(),
            implied_by_offset: t.implied_by_offset.clone(),
        })
        .collect::<Vec<_>>();
    (vars, parsed_trace)
}

/// Calculates related variables forests from the beginning up to each step in the trace.
/// Variables are related if they appear in a constraint together.
fn make_vars_forests(parsed_trace: &[ParsedSwitchStep]) -> Vec<Option<VariablesForest>> {
    let num_vars = parsed_trace
        .iter()
        .filter_map(|s| s.discr.as_ref())
        .flat_map(|d| d.variables.iter().map(|(id, _)| id))
        .max()
        .copied()
        .unwrap_or(0);

    let mut current = VariablesForest::new(DisjointSet::with_len(num_vars as usize + 1));
    parsed_trace
        .into_iter()
        .map(|s| s.discr.as_ref())
        .map(|d| {
            d.map(|d| {
                d.variables
                    .iter()
                    .map(|(id, _)| *id as usize)
                    .map_windows::<_, _, 2>(|[a, b]| {
                        if !current.is_joined(*a, *b) {
                            VariablesForest::make_mut(&mut current).join(*a, *b);
                        }
                    })
                    .count();
                current.clone()
            })
        })
        .collect()
}

/// Weakens the constraints on steps based on the reachability of the next step.
/// If there are multiple branches that lead to the next step, the constraint can
/// be weakened, so it lets more values to be selected at that particular step.
#[tracing::instrument(level = "debug", skip_all)]
fn weaken_steps<'ctx>(
    trace: &[SwitchStep],
    p_map: &ProgramMap,
    reachability: &impl ProgramReachability,
    parsed_trace: &mut [ParsedSwitchStep<'ctx>],
) {
    const ENABLE_REACHABILITY: bool = false;
    parsed_trace
        .iter_mut()
        .zip(trace.iter().map_windows::<_, _, 2>(|[step, next_step]| {
            /* NOTE: A more effective approach would be looking at the next step in the full trace.
             * For simplicity, we currently only do it at intra-procedural level. */
            (next_step.location.body == step.location.body).then_some(next_step.location.index)
        }))
        .for_each(|(step, next)| {
            let Some(edges) = p_map
                .cfgs
                .get(&step.location.body)
                .and_then(|cfg| cfg.get(&step.location.index))
            else {
                return;
            };

            weaken_constraint(
                step,
                edges,
                ENABLE_REACHABILITY.then_some((reachability, next)),
            );
        });
}

/// Weakens the path constraint with respect to the next step in the trace.
/// If the next step is reachable through multiple edges, their constraints will
/// be merged (logical or).
/// # Remarks
/// You can disable weakening based on reachability by passing `None`. Then only
/// the CFG will be taken into account.
#[tracing::instrument(level = "debug", skip(outgoing_edges, reachability))]
fn weaken_constraint<'ctx>(
    step: &mut ParsedSwitchStep<'ctx>,
    outgoing_edges: &[CfgEdgeDestination],
    reachability: Option<(&impl ProgramReachability, Option<BasicBlockIndex>)>,
) {
    let out_going_kinds = outgoing_edges
        .iter()
        .map(|(t, _)| *t)
        .zip(cfg_constraints_to_kind(
            outgoing_edges
                .iter()
                .map(|(_, c)| c.expect(Some(step.location))),
            outgoing_edges,
            step.decision.is_boolean(),
        ))
        .collect::<Vec<_>>();

    let taken_kind = step.decision.clone();

    let next = if let Some(next) = reachability.and_then(|(_, next)| next) {
        // If provided (based on the trace)
        next
    } else {
        out_going_kinds
            .iter()
            .find_map(|(target, kind)| (kind.eq(&taken_kind)).then_some(*target))
            .unwrap_or_else(|| {
                panic!(
                    "Could not map constraint back to CFG edge based on the taken step. Decision: {} at {}",
                    taken_kind, step.location,
                )
            })
    };

    // Possible kinds: Constraint kinds (edges) that take us to the next observed step.
    let possible_kinds = out_going_kinds
        .into_iter()
        .filter(|(t, _)| {
            /* NOTE: A more effective approach would be looking at the next step in the full trace.
             * For simplicity, we currently only do it at intra-procedural level. */
            *t == next
                || reachability
                    .and_then(|(r, _)| r.cfg(step.location.body))
                    .is_some_and(|r| r.reachers(&next).contains(t))
        })
        .map(|(_, k)| k);
    let case_count = case_count(outgoing_edges);
    let weakened_kind = possible_kinds
        .into_iter()
        .try_reduce(|acc, k| acc.or(&k, || case_count))
        .map(|k| {
            k.unwrap_or_else(|| {
                panic!(
                    "Could not map constraint back to CFG edge based on target. Decision: {} at {}, Target: {}",
                    taken_kind, step.location, next,
                )
            })
        });

    if let Some(weakened_kind) = weakened_kind {
        step.decision = weakened_kind;
    } else {
        log_debug!(
            "Removing constraint (discriminant). The next basic block ({}), is reachable from all edges of {:?}.",
            next,
            step
        );
        step.discr = None;
    }
}

// NOTE: If the CFG has merged targets, multiple edges for a single target is possible.
fn construct_constraint_kinds_to_satisfy<'ctx, 'b, 'c>(
    taken_case: &'b ConstraintKind<RawCaseValue>,
    outgoing_edges: &'c [CfgEdgeDestination],
    target: BasicBlockIndex,
) -> impl Iterator<Item = ConstraintKind<RawCaseValue>> {
    let target_case_values = cfg_constraints_to(outgoing_edges, target);
    let kinds =
        cfg_constraints_to_kind(target_case_values, outgoing_edges, taken_case.is_boolean());

    let case_count = case_count(outgoing_edges);

    /* NOTE: Reducing or not changes the soundness.
     * Reducing results in weaker constraints, different case values will be explored in separate executions calls.
     * Soundness is dependent on the exclusion of previously seen answers.
     * Not reducing generates more inputs per execution but possible to make no difference. */
    // let kinds = kinds
    //     .into_iter()
    //     .try_reduce(|acc, k| acc.or(&k, || case_count))
    //     .map(|k| k.expect("At least one edge toward the target is expected."));

    let kinds = kinds.into_iter();

    let not_taken = taken_case.clone().not();

    /* Ensure we find something different.
     * This particularly makes difference when the CFG is merged
     * (we may execute different statements, although the paths merge later). */
    kinds.filter_map(move |k| k.and(&not_taken, || case_count))
}

#[tracing::instrument(level = "debug")]
fn constraint_kind_from_outgoing_edge(
    edge_case: CfgConstraint,
    all_edges: &[CfgEdgeDestination],
    is_boolean_switch: bool,
) -> ConstraintKind<u128> {
    use ConstraintKind::*;
    if is_boolean_switch {
        let to_kind = |v| {
            if v == 0 { False } else { True }
        };
        match edge_case {
            CfgConstraint::Case(value) => to_kind(value),
            CfgConstraint::Otherwise => {
                debug_assert_eq!(all_edges.len(), 2);
                /* Although we know that otherwise case for boolean switches is True,
                 * let's not rely on the assumption. */
                let not_value = all_edges.iter().find_map(|(_, v)| v.flatten()).unwrap();
                to_kind(not_value).not()
            }
        }
    } else {
        match edge_case {
            CfgConstraint::Case(value) => OneOf(vec![value]),
            CfgConstraint::Otherwise => {
                OneOf(all_edges.iter().filter_map(|(_, v)| v.flatten()).collect()).not()
            }
        }
    }
}

fn ast_mapper<'ctx, C: Borrow<u128>>(discr: &AstNode<'ctx>) -> impl FnMut(C) -> AstNode<'ctx> {
    let sort = discr.sort();

    move |case| {
        AstNode::BitVector(BVNode(
            z3::ast::BV::from_str(
                discr.ast().get_ctx(),
                discr.as_bit_vector().get_size(),
                &case.borrow().to_string(),
            )
            .unwrap(),
            {
                let AstNodeSort::BitVector(sort) = sort else {
                    unreachable!("Unexpected sort for a non-bool discriminant: {:?}", sort)
                };
                sort
            },
        ))
    }
}

fn case_count(outgoing_edges: &[CfgEdgeDestination]) -> usize {
    outgoing_edges
        .into_iter()
        .flat_map(|(_, c)| c)
        .fold(0, |count, constraint| match constraint {
            CfgConstraint::Case(_) => count.saturating_add(1),
            /* While having otherwise, makes the universe practically infinite,
             * it should appear for exhaustive matches. */
            CfgConstraint::Otherwise => usize::MAX,
        })
}

fn cfg_constraints_to<'c>(
    outgoing_edges: &'c [(u32, Option<CfgConstraint>)],
    target: u32,
) -> impl Iterator<Item = CfgConstraint> {
    outgoing_edges
        .iter()
        .filter(move |(t, _)| *t == target)
        .map(|(_, c)| c.expect(None))
}

fn cfg_constraints_to_kind<'c>(
    constraints: impl IntoIterator<Item = CfgConstraint>,
    outgoing_edges: &'c [(u32, Option<CfgConstraint>)],
    is_boolean_switch: bool,
) -> impl Iterator<Item = ConstraintKind<RawCaseValue>> {
    constraints.into_iter().map(move |case| {
        constraint_kind_from_outgoing_edge(case, outgoing_edges, is_boolean_switch)
    })
}

trait CfgConstraintExt {
    fn flatten(self) -> Option<u128>;
    fn expect(&self, location: Option<BasicBlockLocation>) -> CfgConstraint;
}

impl CfgConstraintExt for Option<CfgConstraint> {
    fn flatten(self) -> Option<u128> {
        self.and_then(|c| match c {
            CfgConstraint::Case(value) => Some(value),
            CfgConstraint::Otherwise => None,
        })
    }

    fn expect(&self, location: Option<BasicBlockLocation>) -> CfgConstraint {
        self.unwrap_or_else(|| {
            unreachable!(
                "Unconstrained decision is not expected {}",
                location.map(|l| format!("at {l}")).unwrap_or("".to_owned()),
            )
        })
    }
}
